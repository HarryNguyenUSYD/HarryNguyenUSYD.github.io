import SingleImage from "@/global/mdx/SingleImage/SingleImage";
import References from "@/global/mdx/References/References";
import CodeBlock from "@/global/mdx/CodeBlock/CodeBlock";
import Redirect from "@/global/mdx/Redirect/Redirect";
import Table from '@/global/mdx/Table/Table';

# Welcome Back!

Hello and welcome to the sixth episode of my series on .NET, where we are discussing everything you need to know about .NET and it's languages,
primarily C#.

Today we will talk about methods in C#. Methods are the C#'s equivalent of functions from other programming languages (in fact we use both terms
interchangeably). They are useful tools that allow us to reuse code, but more importantly, they are a core element in C#'s OOP, being basic building
blocks for classes and objects (we will talk more about this next week).

While discussing this topic, we will give some examples relating to C# data structures, a topic we covered last week.
If you want to know more about it, feel free to check it out <Redirect name="here" url="/blogs/dotnet-guide-5" />.

Today's topic is both important and interesting, so let's get straight into it.

# Basic Syntax

Much like functions in other languages like Java and Python, C# methods may take in some number of inputs and return some number of outputs. We include all
of these inputs/outputs along with the method's name at declaration.

C# methods can be declared in a similar fashion to Java functions:

<CodeBlock
    language="csharp"
    code={`<return_type> <method_name>(<arguments>) {
    // Do something...
    
    return <return_value>
}`}
/>

- `<return_type>` is the type of the method's return value. These can be anything, ranging from variable types, objects, and even other methods. If a method
doesn't return anything, its will be declared as `void`.
- `<method_name>` is the name of the method. It follows the same rules as variable naming, but there are some common convention for naming methods. You can
check them out <Redirect name="here" url="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/identifier-names" />.
- `<arguments>` is the list of inputs the method can take. We separate these inputs using a comma `,`.
- `<return_value>` is the value the method outputs.

For example, say you want to make a method that takes two numbers and return their sum. It would look something like this:

<CodeBlock
    language="csharp"
    copiable={true}
    code={`double sum(double intA, double intB) {
    return intA + intB;
}`}
/>

Simple, right? To call that method, we simply use the method's name and its inputs:

<CodeBlock
    language="csharp"
    copiable={true}
    code={`double result = sum(1.15, 2.10);

Console.WriteLine(result);

// Output: 3.25`}
/>

# Tricks With Arguments

## Named Arguments

C# allows us to refer to each argument by name when calling a method. For instance, given a method like this:

<CodeBlock
    language="csharp"
    copiable={true}
    code={`void printEverything(int i, string s, double d) {
    Console.WriteLine(i);
    Console.WriteLine(s);
    Console.WriteLine(d);
}`}
/>

There are a wide variety of ways you can call this method. Here are just some examples:

<CodeBlock
    language="csharp"
    copiable={true}
    code={`printEverything(5, "Hello", 3.14);
printEverything(i: 5, "Hello", 3.14);
printEverything(i: 5, s: "Hello", d: 3.14);
printEverything(s: "Hello", i: 5, d: 3.14);`}
/>

All of these calls result in the same outputs. The ability to call arguments by name is known as named arguments, allowing you to shuffle arguments in
whatever way we want. Note that when used with positional arguments, named arguments are only valid when either:

- They're not followed by any positional arguments. (e.g. `printEverything(i: 5, s: "Hello", d: 3.14)`)
- They're used in the correct position. (e.g. `printEverything(i: 5, "Hello", 3.14);`)

By itself, it's not really useful in most scenarios. But it will be, when you combine this feature with...

## Optional Values

Let's say you are making a method that returns the top elements of a C# List. Given that all of your use cases for this method is to get the first 5, you
decide to hard-code the number of elements to 10. Not exactly a good decision, but hey, it's your code.

Since you have learnt how C# Lists work from last week, you make something like this:

<CodeBlock
    language="csharp"
    copiable={true}
    code={`List<int> getHead(List<int> inList)
{
    List<int> outList = new List<int>();
    for (int i = 0; i < 5; i++)
    {
        outList.Add(inList[i]);
    }

    return outList;
}

// Create the input List
List<int> list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Create the output List
List<int> result = getHead(list);

// Print out all elements in the new List
foreach (int element in result)
{
    Console.Write(element + ", ");
}

/*
Output: 1, 2, 3, 4, 5, 
*/`}
/>

Great, your code works well (well done!) and is seemingly bug-free (not really). You make a bunch of calls to this method all over your program,
and everything is looking fine.

But now you realised you need to make this method work for ANY number of top elements. It can be 5, it can be 10, even 100 (let's ignore some
potential bugs for now). The simplest and best idea is to add an argument to your method, taking in an extra integer. However, this requires you to change
all of your previous calls from `getHead(list)` to `getHead(list, 5)`, which is extremely time consuming. If only there was a way for you to keep the old
syntax and still have the same functionality...

Luckily, C# does support default values for methods, known as optional arguments. This feature allows you to define a default value for any argument, and
unless it is overriden by a call, the method will treat the default value as the input (hence "optional").

For instance, we can modify the above method to something like this:

<CodeBlock
    language="csharp"
    copiable={true}
    code={`List<int> getHead(List<int> inList, int count = 5)
{
    List<int> outList = new List<int>();
    for (int i = 0; i < count; i++)
    {
        outList.Add(inList[i]);
    }

    return outList;
}

// Create the input List
List<int> list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Create the output List for default input
List<int> defaultResult = getHead(list);

// Print out all elements in the default List
foreach (int element in defaultResult)
{
    Console.Write(element + ", ");
}

// Output: 1, 2, 3, 4, 5, 

// Create line for new output:
Console.WriteLine("");

// Create the output List for overriden input
List<int> overridenResult = getHead(list, 3);

// Print out all elements in the overriden List
foreach (int element in overridenResult)
{
    Console.Write(element + ", ");
}

// Output: 1, 2, 3, `}
/>

Notice how we put `int count = 5` in the arguments? Here, `5` is the default value of the `count` argument, meaning the method will use `count = 5` if
not overriden. This is useful since we don't have to replace previous calls when extending functionality for a currently used method, or
when we know this method will most likely be called with a certain value and we want to save time for those calls.

Note that optional arguments have to be placed at the end of the argument list, after all the non-optional ones.

## Combine These Together

What happens when there are multiple optional arguments? Suppose there's a method like this:

<CodeBlock
    language="csharp"
    copiable={true}
    code={`void printEverything(int i = 5, string s = "Hello", double d = 3.14) {
    Console.WriteLine(i);
    Console.WriteLine(s);
    Console.WriteLine(d);
}`}
/>

Overriding `i` is simple (e.g. `printEverything(10)`), but what if you want to override `s`? This is where named arguments become usefull:

<CodeBlock
    language="csharp"
    copiable={true}
    code={`printEverything(s: "World");`}
/>

Here, we used named arguments to override `s` and skip the other values.

# Ref and Out

Finally, let's talk about two keywords you will occasionally see in C#: `ref` and `out`. These two are both argument modifiers, meaning you can add either
of them in front of arguments to make them behave differently.

`ref` is a keyword for when you want to pass a variable into a method, but to do so specifically as a reference (instead of by value). This might sound
confusing, but it will be much easier to understand with an example.

Take a look at these two methods: `addToInt` and `addToIntWithRef`.

<CodeBlock
    language="csharp"
    copiable={true}
    code={`// Add 10 to a variable without ref
int addToInt(int input)
{
    input += 10;

    return input;
}

// Add 10 to a variable with ref
int addToIntWithRef(ref int input)
{
    input += 10;

    return input;
}

// Call the methods
int i = 10;

Console.WriteLine("Without ref: " + addToInt(i));
Console.WriteLine("Current i value: " + i);
Console.WriteLine("With ref: " + addToIntWithRef(ref i));
Console.WriteLine("Current i value: " + i);`}
/>

Notice how the value stored in `i` changed after calling the method with `ref`? Since `i` was passed in as a reference, the data stored in the original
variable is changed as well, instead of staying the same (as seen when calling the regular `addToInt`). This is useful if you want to pass a value-type
variable (like `int`, `float`, `char`, etc.) but you want the original variable to be changed at the same time.

`out` is another keyword that behaves very similarly, but slightly different:

<CodeBlock
    language="csharp"
    copiable={true}
    code={`// Set a variable to 10 without out
// In VSCode, you might see the message "Parameter 'input' can be removed; its initial value is never used" when hovering "input".
int setInt(int input)
{
    input = 10;

    return input;
}

// Set a variable to 10 with out
int setIntWithOut(out int input)
{
    input = 10;

    return input;
}

// Call the methods
int i = 0;

Console.WriteLine("Without out: " + setInt(i));
Console.WriteLine("Current i value: " + i);
Console.WriteLine("With out: " + setIntWithOut(out i));
Console.WriteLine("Current i value: " + i);`}
/>

Unlike `ref`, which assumes that the variable is already defined prior to being passed, `out` allows you to declare the variable inside the method,
reflecting that change outside the method as well. This is useful since it effectively allows methods to return multiple values, one normally, and
one more for every `out` variables.

It is difficult to list all the differences between `ref` and `out` without diving deeper into C# and how it works in the background. Therefore, if you
want to know more about them, check out <Redirect name="this" url="https://www.c-sharpcorner.com/UploadFile/ff2f08/ref-vs-out-keywords-in-C-Sharp/" />
interesting post I found.

# Conclusion

And that's it! We have discussed methods and some related features of C#.

Next week we will talk about my favourite topic in C#: OOP. I hope everyone reading this is as excited as I am (judging by the number of views, there's
not that many of you guys, so I really appreciate the support).

Finally, make sure to give this post a like and share it with your friends. If you have any feedback, perhaps an idea for a blog, send me an email and I'll respond as
soon as I can. For now, have fun learning!