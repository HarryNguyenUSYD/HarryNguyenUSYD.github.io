import References from "@/global/mdx/References/References";
import CodeBlock from "@/global/mdx/CodeBlock/CodeBlock";
import Code from "@/global/mdx/Code/Code";

# Welcome To a New Series

Welcome to the first instalment of my new "Introduction to .NET" series (the first Guide series on this site!), where I will walk you through everything
you need to know about starting your first .NET project (and/or land your interview 20 minutes from now). For this episode, we will talk
about how .NET began, what .NET is made up of, and why .NET is better than any of its competitors.

Since our topic of discussion today requires a lot of technological terms and concepts, I would recommend to only read this series if you
are an intermediate/advanced member of the coding field. For beginners, don't worry, there will be another series for you tackling all the basic knowledge
you need to start programming.

Without further ado, let's begin with every elder programmer's nightmare.

# "DLL Hell"

So back in the olden days of the year 2000, developing Windows applications required a wide range of tools that, surprisingly, did not work well with
each other. C/C++ with Win32 API was the most commonly used back-end languages, combined with ActiveX Data Objects (ADO) for database connection,
and Active Server Pages (ASP) for web applications. For GUI development, Microsoft Foundation Class Library (MFC) or Visual Basic 6.0 (VB6) are used.
These tools and languages are then connected together using Component Object Model (COM), which was later extended into DCOM, then combined with
Microsoft Transaction Server (MTS) to become COM+.

The trouble is, each of these tools and languages has tons of limitations that made them difficult to work with: C/C++ required manual memory management
and steep learning curve; Classic ASP had a variety of security issues that caused some notable incidents, including the Download.ject attack in 2004;
MFC and VB6 were too complex for simple tasks and lacked structured exception handling, just to name a few. But the most significant problem with all of
these tools was their dependence on COM and its variants as a "glue", and that led to plenty of issues around Windows development at that time.

The most infamous of those issues were <Code code=".dll" /> files. DLLs, or Dynamic Link Libraries, are files that contain reusable code, data, and resources that can
be shared across multiple programs on Windows. Most of the tools listed above would have one or more of these, as well as any extra software or other
tools you need to work with. When a developer writes a class that implements one or more COM interfaces, that code will be compiled into a <Code code=".dll" /> file.
The DLL is then registered to the Windows Registry, which maps each COM class to the its file path, allowing COM to find and load it.

DLLs were great for their purpose: they enables reusable code and runtime loading, they help with separating components,
and most importantly, they allow developers to extend the functionality of existing applications without modifying the core codebase. However, all <Code code=".dll" />
files have a major problem regarding versioning, specifically because DLLs were only identified by their file names and not by version number,
build date, or signature. Installing a new DLL, even with changes, would silently overwrote an older version, causing other applications using the
original version to crash or behave unpredictably. This was amplified by the fact that DLLs were frequently installed into the System32 source
directory (e.g. <Code code="C:\Windows\System32" />), and that multiple applications shared the same copy of a DLL. This would lead to a phenomenon known as "DLL Stomping",
where a newly-installed application overwrites an existing DLL with an earlier, incompatible version.

This issue gave rise to the term "DLL Hell", a term that symbolises the problems developers may face when dealing with DLLs in older Windows system. These
problems manifest themshelves in many ways, such as programs suddenly not working correctly, or would not run at all. Developers would spend hours tracking
down what went wrong, only to realise that the DLLs they were using has been replaced with a wrong version at some point. And since every application has
their own copies of <Code code=".dll" /> files, and most projects need to use dozens of applications, it is easy to understand the frustration every Windows developer of the
era had to went through.

# Here Comes a New Challenger!

To deal with all of those issues, as well as to compete against the rise of Java as a platform for web and enterprise applications, Microsoft began to
develop a framework called Next Generation Windows Services (NGWS), which became later known as .NET. The project began in the late 1990s, with the first
beta version released in late 2001. Over the years and across many updates, .NET has proven itself to be a powerful open-source, cross-platform developer
platform for building modern applications, with the newest version (as of writing this blog) being .NET 9.

As a platform, .NET has a long list of components that keeps getting longer every releases. The list includes:

- Common Language Runtime (CLR), the execution engine of .NET. This component manages the loading and compiling of .NET files, type-checking,
garbage collection, and more.
- C# as the primary programming language. It is a general-purpose, low-level, object-oriented, functional language that supports asynchronization and
targets the CLR. 
- .NET Framework Class Library, an object-oriented library that tightly integrates with the CLR. The library is primarily written in C# and Visual Basic,
but it can also be used with other languages like F# and C++/CLI.
- .NET CLI, a cross-platform toolchain for developing, building, running, and publishing .NET applications. It consists of the dotnet driver, commands, and
optional arguments.

<CodeBlock
    language="bash"
    desc="A sample usage of .NET CLI (source: .NET CLI overview by Microsoft)"
    code={`dotnet new console
dotnet build --output ./build_output
dotnet ./build_output/my_app.dll`}
/>

There are also many application frameworks designed for .NET, such as ASP.NET, .NET MAUI, WinForms, etc. All in all, .NET is a massive ecosystem for
developers, suitable not just for Windows but also for web, mobile, cloud, and AI development.

# Alternatives
