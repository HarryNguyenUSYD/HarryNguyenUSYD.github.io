import SingleImage from "@/global/mdx/SingleImage/SingleImage";
import References from "@/global/mdx/References/References";
import CodeBlock from "@/global/mdx/CodeBlock/CodeBlock";
import Redirect from "@/global/mdx/Redirect/Redirect";
import Table from '@/global/mdx/Table/Table';

# Welcome To Today's Class!

Hello and welcome to the latest episode of my series on .NET.

Today we will begin our sub-series on C# OOP features, one of the main selling point of the language. We will start with a quick talk on what OOP is,
which will allow us to discuss the `class` keyword, unlocking one of the must-know features of C#.

If you want to know more about C#'s methods, one of the topics we will use a lot today, check it out <Redirect name="here" url="/blogs/dotnet-guide-6"/>!.

Without further ado, let's get into it!

# Everything Starts With A Problem

Object Oriented Programming (OOP) is one of the main programming paradigms used by many modern programming languages.

> Note: For a quick explantion of programming paradigms, check out my blog on the basics of programming <Redirect name="here" url="/blogs/programming-1"/>.

It is easier to understand OOP by starting with a problem. Let's say you own a zoo, and you want to implement some sort of system that will tell the
public fun facts about the animal species. Not only that, you also need the animals to interact with each other, meaning each species will do something
different depending on what other species it interacts with.

Sounds simple enough, right? Not exactly.

Firstly, you have to consider that there can be a lot of animal species at the zoo (the Taronga Zoo in Sydney has over 350!). This means you can't
implement each animal individually, since that would take ages (and stockholders do not like that). Secondly, since animals interact with one another, you
have to come up with some way to make these interactions easy to search through and used, meaning storing all of them in a list is not a good idea.

Luckily, you also notice one important thing: all animals have some similar aspects you want to store (e.g. name, height, weight, interactions). If you can
somehow create a template that contains all of these aspects, then somehow being able to modify each template to match each species, this problem will be
solved in no time.

This is where OOP comes in. The main idea of OOP is to construct all similar aspects of every species into a "blueprint", then modify that "blueprint"
individually for each species. This "blueprint" is commonly referred to as a `class`. For instance, say you want to store the name, height, and weight
of each species. The `class` will then contain a variable (referred to as an field) for name, another for height, and another for weight. Then, for
each species, we create an instance of the `class`, filling it with different information depending on the animal.

For this task, suppose we want to store these following aspects about a species:

- Name
- Size (kg)
- Lifespan (X - Y years)
- Description

Great! Using C#, our `class` will look something like this:

<CodeBlock
    language="csharp"
    copiable={true}
    code={`public class Species {
    public string name;
    public double size;
    public int[] lifespan;
    public string description;

    public Species(string name, double size, int[] lifespan, string description) {
        this.name = name;
        this.size = size;
        this.description = description;

        // Only accept the argument if it has a length of 2
        if (lifespan.Length == 2)
        {
            this.lifespan = lifespan;
        }
        else
        {
            this.lifespan = [0, 0];
        }

        // Print something to see if an instance of this class was created
        Console.WriteLine("An animal was created!");
    }    
}`}
/>

Notice the `Species` method that doesn't have a return value? That is called a constructor, a method that is called whenever a new instance of the class
is created. It is mainly used to initialize the starting values of the instance, but it can do anything a regular method can, except for returning values.

To create an instance of `Animal`, we use this syntax:

<CodeBlock
    language="csharp"
    copiable={true}
    code={`Species chicken = new Species("Chicken", 2.5, [5, 10], "A common farm animal whose meat and eggs are tasty!");`}
/>

> Note: If you want to try out this line in the same file as the class, put the line on top of the file, before the class declaration. C# will throw an
error if you don't do that.

We can access the data inside each instance like this:

<CodeBlock
    language="csharp"
    copiable={true}
    code={`// Getting the field
Console.WriteLine("This animal is a: " + chicken.name);

// Setting the field
chicken.name = "Hungry Chicken";

// See if the change is reflected
Console.WriteLine("This animal is a: " + chicken.name);`}
/>

# Handling Interactions

In addition to fields, `class`es can also have their own methods, symbolizing actions that all animals can do (e.g. eat, sleep, drink). This will be
how we implement species interactions.

Let's simplify interactions like this: when a species A meets another species B, where A is the species whose instance we are making, A will say something
differently. For example, chickens have no trouble being around ducks (saying "Hey Duck!"), but it panics while being around foxes (saying "Ah Fox!").

The best strategy for making these interactions is by creating another class for them. Something like this:

<CodeBlock
    language="csharp"
    copiable={true}
    code={`public class Interaction {
    public Species speciesA;
    public Species speciesB;
    public string sound;

    public Interaction(Species speciesA, Species speciesB, string sound) {
        this.speciesA = speciesA;
        this.speciesB = speciesB;
        this.sound = sound;

        // Print something to see if an instance of this class was created
        Console.WriteLine("An interaction was created!");
    }

    public void Interact() {
        Console.WriteLine(this.sound);
    }
}`}
/>

Notice how other classes, in this case `Species`, can be a data type? Classes are itself a data type, and as such can be passed around as arguments or stored
as fields.

Also, see how there is a method `Interact()` in the class? This method is the same across all instances of this class, but the data it uses (in this case,
`sound`) is different for each instance. Let's try it out:

<CodeBlock
    language="csharp"
    copiable={true}
    code={`// Creating the three species
Species chicken = new Species("Chicken", 2.5, [5, 10], "A common farm animal whose meat and eggs are tasty!");
Species duck = new Species("Duck", 1.1, [5, 10], "A farm animal, but you sometimes see them in parks!");
Species fox = new Species("Chicken", 6, [3, 4], "A wild animal that likes eating chicken!");

// Creating the interactions
Interaction interactionChickenDuck = new Interaction(chicken, duck, "Hey Duck!");
Interaction interactionChickenFox = new Interaction(chicken, fox, "Ah Fox!");

// Calling the interaction methods
interactionChickenDuck.Interact(); // Prints out "Hey Duck!"
interactionChickenFox.Interact(); // Prints out "Ah Fox!"`}
/>

And like that, we can create different interactions for all animals.

# Access Modifiers

You may have noticed the `public` keyword being used all over the place before the classes, fields, and methods we wrote above. `public` is one of many
access modifiers that C# offers. Access modifiers are used to modify the access level of a class, field, or method. In other words, these keywords decide
if the data can be used by all other classes, only by the class itself, or only by some specific classes. All of the access modifiers in C# are:

<Table
    columns={["Name", "Description"]}
    content={[
        ["public", "The member is accessible from anywhere in the program or other assemblies."],
        ["private", "The member is accessible only within the containing class or struct."],
        ["protected", "The member is accessible within the containing class and its derived classes."],
        ["internal", "The member is accessible within the same assembly, but not from another assembly."],
        ["protected internal", "The member is accessible from the same assembly or from derived classes in other assemblies."],
        ["private protected", "The member is accessible only within its containing class or derived classes that are in the same assembly."]
    ]}
/>

> Note: We will discuss the concept of assemblies in later weeks.

A good way of imagining access modifiers is to think about buildings.

`public` is like a public (duh) building, such as libraries, stores, restaurants, etc. Anyone can come in, regardless of their relationship with the building
owner.

`private` is like a common household. Only the owners of the house can enter (and they won't let any guest in!).

`protected` is like a household owned by a family of many generations. The original owners, your parents live there, but your grandparents can visit at any
point, and you can come whenever you want as well. We will discuss this concept, called inheritance, next week.

`internal` is like an apartment complex. Anyone who lives in the same building (the same assembly) can freely visit the shared areas,
but outsiders (other assemblies) cannot enter.

`protected internal` is like a family-owned hotel. Family members (derived classes) can stay there, and so can residents
of the same city (same assembly). Outsiders who are neither family nor local aren't allowed.

`private protected` is like a family-owned private estate, but only your branch of the family owns it. Only family members in your branch can enter.
Strangers, and even family from outside (such as your second cousin Dave) isn't allowed.

# Wait, Why Access Modifers?

You may wonder why we can't just make everything `public` and make it easy for everyone. The truth is, it isn't: everything being `public` is a lot harder
to manage. To further understand why, we need to talk about the four principles of OOP. They are: **encapsulation, abstraction, inheritance, and polymorphism**.

**Encapsulation** means that all the complex data around an object, fields, methods and whatnot, are all combined into a simple object called a class. Think of
a class as a tiny laptop that contains all of the files, folders, and programs to do your work. Having all of these things in a laptop allows you to easily
carry it around, ship it to other people, or make copies of it, etc.

**Abstraction** means that you don't really need to know all the details about the laptop to effectively use it. Most of the time, you won't have to worry
about how the screen's LED work, or how the keyboard works, or how the system OS is run to do your work. Having it hidden means you have to think about less
things and make your work easier.

**Inheritance** means that your laptop can be reused by others to make their own versions, each reusing your data more suitable for their work. Maybe you
have a good calculator program on your laptop, something a mathematician can copy and create a better one for his work. And another researcher can take
the mathematician's copy and make a better one, so on and so forth.

**Polymorphism** means that your laptop can do exactly the same things as a desktop computer can, each with the exact same interface, but different
underlying mechanics. Your laptop will have much less RAM, CPU and memory than a desktop computer, but both can run Windows and play games the exact same
way.

Regarding the `public` question, the answer is that it violates the **abstraction** principle. Having access to every member of a class makes it way too
complicated to do your work, especially when there can be hundreds of fields and methods in any class. More importantly, it is also risky for you to modify
any member at will, since you can break something inside the class, rendering it useless (this is why you shouldn't touch the terminal unless you know
what you're doing!).

# Conclusion

And that's it! We have discussed the first few concepts about OOP in C#.

Next week we will talk about inheritance in C#, an interesting and useful feature that allows us to build some truly wonderful projects. I hope you are
looking forward to it as much as I am.

Finally, make sure to give this post a like and share it with your friends. If you have any feedback, perhaps an idea for a blog, send me an email and I'll respond as
soon as I can. For now, have fun learning!